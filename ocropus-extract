#!/usr/bin/python
import code,pickle,sys,os,re,traceback,sqlite3
from optparse import OptionParser
from pylab import *
import ocrolib
from ocrolib import docproc,Record,utils,fstutils

parser = OptionParser("""
usage: %prog [options] .../.../010001.png ...

Extract character images from text line image files using the cseg files
left by the recognizer; character images are labeled by their corresponding 
characters in the .txt files.  

You must run ocropus-lattices and ocropus-align first to obtain the cseg 
and txt files.  You can also manually create the cseg and txt files.
""")

parser.add_option("-g","--gtsuffix",help="ground truth suffix",default=None)
parser.add_option("-o","--output",help="output file",default="chars.db")
parser.add_option("-u","--unmerged",help="unmerged output file",default=None)
parser.add_option("-n","--nomissegmented",help="output no missegmented characters",action="store_true")
parser.add_option("-r","--raw",help="output unlabeled characters",action="store_true")
parser.add_option("-a","--maxage",help="output missegmented",default=10000000,type="int")
parser.add_option("-D","--display",help="display chars",action="store_true")
parser.add_option("-v","--verbose",help="verbose output",action="store_true")
parser.add_option("-N","--nosource",help="do not record source info",action="store_true")
parser.add_option("-c","--cerrors",help="continue even if errors are found",action="store_true")
parser.add_option("-E","--extracost",help="cost for misaligned characters",type=float,default=0.0)

(options,args) = parser.parse_args()
args = ocrolib.expand_args(args)

if len(args)<1:
    parser.print_help()
    sys.exit(0)

ion()
show()

if os.path.exists(options.output):
    print options.output,"exists; please remove"
    sys.exit(1)

table = "chars"

db = sqlite3.connect(options.output,timeout=600.0)
db.row_factory = utils.DbRow
db.text_factory = sqlite3.OptimizedUnicode
db.execute("pragma synchronous=0")
utils.charcolumns(db,table)
db.commit()

class BadGroundTruth(Exception):
    pass

def cseg_chars(file,suffix=options.gtsuffix):
    image = ocrolib.read_image_gray(file)
    image = 255-image
    cseg_file = ocrolib.ffind(file,"cseg")
    cseg = ocrolib.read_line_segmentation(cseg_file)
    with ocrolib.fopen(file,"txt") as stream:
        gt = stream.read()
    with ocrolib.fopen(file,"costs") as stream:
        costs = array([float(s.split()[1]) for s in stream.readlines()])[1:]
    assert len(gt)==len(costs),"gt and costs differ: %d != %d"%(len(gt),len(costs))
    gt = re.sub('\n','',gt)
    gt = fstutils.explode_transcription(gt)
    geo = docproc.seg_geometry(cseg)
    grouper = ocrolib.StandardGrouper()
    grouper.pset("maxrange",1)
    grouper.setSegmentation(cseg)
    # print grouper.length(),len(gt),len(re.sub(' ','',gt))
    if len(gt)!=grouper.length():
        gt = re.sub(' ','',gt)
        if len(gt)!=grouper.length():
            raise BadGroundTruth()
    for i in range(grouper.length()):
        cls = gt[i]
        cost = costs[i]
        if cls==' ': continue
        raw,mask = grouper.extractWithMask(image,i,1)
        yield Record(raw=raw,mask=mask,cls=cls,index=i,bbox=grouper.boundingBox(i),
                     bbox_m=grouper.bboxMath(i),lgeo=geo,cost=cost)

def cseg_chars_all(file,suffix=options.gtsuffix):
    image = ocrolib.read_image_gray(file)
    image = 255-image
    cseg_file = ocrolib.ffind(file,"cseg")
    rseg_file = ocrolib.ffind(file,"rseg")
    cseg = ocrolib.read_line_segmentation(cseg_file)
    rseg = ocrolib.read_line_segmentation(rseg_file)
    with ocrolib.fopen(file,"txt") as stream: gt = stream.read()
    gt = gt.decode("utf-8")
    gt = re.sub('\n','',gt)
    gt = fstutils.explode_transcription(gt)
    costs = [None]*(1+len(gt))
    with ocrolib.fopen(file,"costs") as stream:
        for line in stream.readlines():
            f = line.split()
            costs[int(f[0])] = float(f[1])
    assert len(gt)<=len(costs),\
        "gt and costs differ: %d != %d"%(len(gt),len(costs))
    geo = docproc.seg_geometry(cseg)
    grouper = ocrolib.StandardGrouper()
    grouper.setSegmentationAndGt(rseg,cseg,gt)
    for i in range(grouper.length()):
        index = grouper.getGtIndex(i)
        cls = grouper.getGtClass(i)
        cost= costs[index] if index>=0 else options.extracost
        if cls==' ': continue
        raw,mask = grouper.extractWithMask(image,i,1)
        yield Record(raw=raw,mask=mask,cls=cls,index=grouper.getGtIndex(i),
                     bbox=grouper.boundingBox(i),
                     bbox_m=grouper.bboxMath(i),lgeo=geo,cost=cost)

ntried = 0
nfiles = 0
total = 0

for file in args:
    segments = []
    text = ""
    ntried += 1
    try:
        if options.nomissegmented:
            items = list(cseg_chars(file))
        else:
            items = list(cseg_chars_all(file))
        nfiles += 1
    except IOError,e:
        print "ERROR",e
        print "# cseg for",file,"not found (got %d of %d files)"%(nfiles,ntried)
        continue
    except Exception,e:
        if options.cerrors:
            traceback.print_exc()
            print "#",file,"failed",e
            continue
        else:
            traceback.print_exc()
            raise e
    if options.verbose:
        print file,len(segments),len(text)
    index = 0
    for x in items:
        raw = x.raw
        mask = x.mask
        cls = x.cls
        cost = x.cost
        # print index,cls
        index += 1
        segments.append(raw)
        if options.display:
            clf(); gray(); imshow(raw); draw()
        text += cls
        if cls is None:
            # no ground truth
            if not options.raw: continue
            cls = "_"
        elif cls<=0 or cls=="":
            # missegmented
            if not options.missegmented: continue
            cls = "~"
        if raw.shape[0]>255 or raw.shape[1]>255: continue
        raw = raw/float(amax(raw))
        key = re.sub(r'^.*/(\d\d\d\d/)','\\1',file)
        key = re.sub(r'\.png$','',key)
        if options.verbose:
            print key,cls,raw.shape
        if options.nosource:
            utils.dbinsert(db,table,
                           image=utils.image2blob(raw),
                           cost=cost,
                           cls=cls,
                           count=1,
                           lgeo="%g %g %g"%x.lgeo)
        else:
            x0,y0,x1,y1 = x.bbox_m
            rel = docproc.rel_char_geom((y0,y1,x0,x1),x.lgeo)
            ry,rw,rh = rel
            assert rw>0 and rh>0
            utils.dbinsert(db,table,
                           image=utils.image2blob(raw),
                           cost=cost,
                           cls=cls,
                           count=1,
                           file=file,
                           lgeo="%g %g %g"%x.lgeo,
                           rel="%g %g %g"%rel,
                           bbox="%d %d %d %d"%x.bbox_m)
        total+=1
        if total%10000==0:
            print total,"chars"
            db.commit()


db.commit()
print total,"chars"
