#!/usr/bin/python

# make the clustering class-specific

import sys,os,re,glob,math,glob,signal,traceback
if "DISPLAY" not in os.environ:
    import matplotlib
    matplotlib.use("AGG")
from scipy.ndimage import interpolation
from pylab import *
from optparse import OptionParser
from multiprocessing import Pool
import ocrolib
from ocrolib import number_of_processors,fstutils,die
from scipy import stats

signal.signal(signal.SIGINT,lambda *args:sys.exit(1))

parser = OptionParser("""
usage: 
%prog [-s gt] [-l langmod] [options] file.fst ...

    Align each file.fst with language model and output the result into
    file.cseg.png, file.costs, and file.txt.  With -s gt, writes the
    results into file.cseg.gt.png, file.gt.costs, and file.gt.txt 
    instead.

%prog [-s gt] [-g extension] [options] *.fst

    Align with groundtruth files.  For each x.fst, looks for the ground truth
    in x.extension

%prog [-s gt] [-p] [options] *.gt.txt

    Align with page-level ground truth.  For each page.gt.txt, looks in
    page/??????.png for the image data.

Aligns recognition lattices (stored in .fst files) with language models and/or
ground truth.  If -g extension is given, each foo.fst file is aligned with a
corresponding foo.extension file.  

Language models and ground truth files may be given either as FST files or 
text files.  If they are given as text files, an FST is constructed by using
the fstutils.add_line_to_fst function.

""")


parser.add_option("-l","--langmod",help="language model",default=None)
parser.add_option("-L","--ligatures",help="output ligatures in aligned text",action="store_true")
parser.add_option("-B","--beam",help="size of beam",type=int,default=1000)
parser.add_option("-N","--noligatures",help="don't expand ligature notation in transcriptions",action="store_true")
parser.add_option("-g","--gt",help="extension for ground truth",default=None)
parser.add_option("-p","--pagegt",help="arguments are page ground truth",action="store_true")
parser.add_option("-s","--suffix",help="output suffix for writing result",default=None)
parser.add_option("-O","--overwrite",help="overwrite outputs",action="store_true")
parser.add_option("-Q","--parallel",type=int,default=0,help="number of parallel processes to use")
parser.add_option("-P","--perc",help="percentile for reporting statistics",type=float,default=90.0)
parser.add_option("-M","--maxperc",help="maximum cost at percentile",type=float,default=2.0)
parser.add_option("-A","--maxavg",help="maximum average cost",type=float,default=3.0)
(options,args) = parser.parse_args()
args = ocrolib.expand_args(args)

aligner = fstutils.DefaultAligner()

lfile = None
lfst = None

def safe_align1(t):
    try:
        align1(t)
    except e:
        traceback.print_exc()

def align1(t):
    global lfile,lfst
    (fname,lmodel) = t
    ocrolib.fcleanup(fname,options.suffix,["txt","costs"])

    try:
        fst = ocrolib.OcroFST()
        fst.load(ocrolib.ffind(fname,"fst"))
        rseg = ocrolib.read_line_segmentation(ocrolib.ffind(fname,"rseg"))

        if lmodel!=lfile:
            lfile = lmodel
            nolig = not options.noligatures
            if lmodel.endswith(".fst"):
                lfst = ocrolib.OcroFST().load(lmodel)
            else:
                lfst = aligner.ocroFstForFile(lmodel)
        
        r = ocrolib.compute_alignment(fst,rseg,lfst)

        if options.ligatures:
            result = r.output_t
        else:
            result = r.output
        cseg = r.cseg
        costs = r.costs

        perc = stats.scoreatpercentile(costs,options.perc)
        avg = mean(costs)
        skip = (perc > options.maxperc or avg>options.maxavg)

        if len(r.output)==0:
            print "* %s: *****"%(fname,)
            return
        else:
            print "%-1s %s: %5.2f %5.2f: %s"%("*" if skip else " ",fname,perc,avg,result)
            if skip: return

        cseg_file = ocrolib.fvariant(fname,"cseg",options.suffix)
        if not options.overwrite:
            if os.path.exists(cseg_file): die("%s: already exists",cseg_file)
        ocrolib.write_line_segmentation(cseg_file,cseg)
        ocrolib.write_text(ocrolib.fvariant(fname,"txt",options.suffix),result)
        with ocrolib.fopen(fname,"costs",options.suffix,mode="w") as stream:
            for i in range(len(costs)):
                stream.write("%d %g\n"%(i,costs[i]))
    except IOError,e:
        print "# not found:",e

jobs = []

if options.pagegt is not None:
    for arg in args:
        if not os.path.exists(arg):
            print "# %s: not found"%arg
            continue
        base,_ = ocrolib.allsplitext(arg)
        if not os.path.exists(base):
            print "# %s: base dir not found"%base
            continue
        if not os.path.isdir(base):
            print "# %s: not a directory"%base
            continue
        lines = glob.glob(base+"/??????.png")
        for line in lines:
            jobs.append((line,arg))
elif options.langmod is not None:
    for arg in args:
        jobs.append((arg,options.langmod))
elif options.gt is not None:
    for arg in args:
        path,ext = ocrolib.allsplitext(arg)
        p = path+options.gt
        if not os.path.exists(arg):
            print arg,"not found"
            continue
        if not os.path.exists(p): 
            print p,"not found"
            continue
        jobs.append((arg,p))
else:
    raise Exception("you need to specify what kind of groundtruth you want to align with (-p, -l, -g)")

if options.parallel<2:
    for arg in jobs: align1(arg)
else:
    pool = Pool(processes=options.parallel)
    result = pool.map(safe_align1,jobs)
