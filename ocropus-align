#!/usr/bin/python

# make the clustering class-specific

import sys,os,re,glob,math,glob,signal,traceback
if "DISPLAY" not in os.environ:
    import matplotlib
    matplotlib.use("AGG")
from scipy.ndimage import interpolation
from pylab import *
from optparse import OptionParser
from multiprocessing import Pool
import ocrolib
from ocrolib import number_of_processors,fstutils,die
from scipy import stats

signal.signal(signal.SIGINT,lambda *args:sys.exit(1))

parser = OptionParser("""
usage: 
%prog [-s gt] [-l langmod] [options] file.fst ...

    Align each file.fst with language model and output the result into
    file.cseg.png, file.costs, and file.txt.  With -s gt, writes the
    results into file.cseg.gt.png, file.gt.costs, and file.gt.txt 
    instead.

%prog [-s gt] [-g extension] [options] *.fst

    Align with groundtruth files.  For each x.fst, looks for the ground truth
    in x.extension

%prog [-s gt] [-p] [options] *.gt.txt

    Align with page-level ground truth.  For each page.gt.txt, looks in
    page/??????.png for the image data.

Aligns recognition lattices (stored in .fst files) with language models and/or
ground truth.  If -g extension is given, each foo.fst file is aligned with a
corresponding foo.extension file.  

Language models and ground truth files may be given either as FST files or 
text files.  If they are given as text files, an FST is constructed by using
the fstutils.add_line_to_fst function, using the fstutils.default_costs
costs.  These can be overridden using the -c costfile flag, which can
be used to specify a Python file that sets different costs or
a different load_transcription function.

Costs are relative to the ground truth, i.e., to change the ground truth
into the OCR output:

costs.reject                       # cost for matching reject in gt against a character
costs.space_insert                  # cost for inserting an extra space anywhere
costs.space_delete                 # cost for deleting a space 
costs.char_mismatch                # cost for a single character mismatch
costs.char_insert                  # cost for inserting a character
costs.char_delete                  # cost for deleting a character
costs.misseg2                      # cost for matching 1 OCR character against two gt characters
costs.misseg3                      # cost for macthing 1 OCR character against three gt characters

The following apply only when there are ligatures in the ground truth; there are four 
possibilities, according to whether ligatures are represented in the ground truth and/or
in the OCR output.  The choice depends on whether ligatures are marked in the
ground truth, whether the classifier recognizes ligatures, and whether the aligned output
is supposed to contain ligatures:

costs.add_l2l                      # cost for ligature-to-ligature matches
costs.add_c2l                      # cost for character-to-ligature matches of ligatures
costs.add_c2c                      # cost for character-to-character matches of ligatures
costs add_l2c                      # cost for ligature-to-character macthes of ligatures

""")


parser.add_option("-l","--langmod",help="language model",default=None)
parser.add_option("-L","--noligatures",help="don't use ligature syntax in transcriptions",action="store_true")
parser.add_option("-g","--gt",help="extension for ground truth",default=None)
parser.add_option("-p","--pagegt",help="arguments are page ground truth",action="store_true")
parser.add_option("-c","--costs",help="costs file",default=None)
parser.add_option("-s","--suffix",help="output suffix for writing result",default=None)
parser.add_option("-O","--overwrite",help="overwrite outputs",action="store_true")
parser.add_option("-Q","--parallel",type=int,default=0,help="number of parallel processes to use")
parser.add_option("-P","--perc",help="cost percentile",type=float,default=90.0)
parser.add_option("-M","--maxperc",help="maximum cost at percentile",type=float,default=2.0)
parser.add_option("-A","--maxavg",help="maximum average cost",type=float,default=3.0)
(options,args) = parser.parse_args()
args = ocrolib.expand_args(args)

def load_transcription(file):
    return fstutils.load_transcription(file)

costs = fstutils.default_costs

if options.costs is not None:
    execfile(options.costs)

fstutils.default_costs = costs

lfile = None
lfst = None

def safe_align1(t):
    try:
        align1(t)
    except e:
        traceback.print_exc()

def align1(t):
    global lfile,lfst
    (fname,lmodel) = t
    ocrolib.fcleanup(fname,options.suffix,["txt","costs"])

    try:
        fst = ocrolib.OcroFST()
        fst.load(ocrolib.ffind(fname,"fst"))
        rseg = ocrolib.read_line_segmentation(ocrolib.ffind(fname,"rseg"))

        if lmodel!=lfile:
            lfile = lmodel
            lfst = fstutils.load_transcription(lmodel,not options.noligatures)
            lfst.save("_.fst")
        
        r = ocrolib.compute_alignment(fst,rseg,lfst)

        result = r.output_t
        cseg = r.cseg
        costs = r.costs

        perc = stats.scoreatpercentile(costs,options.perc)
        avg = mean(costs)
        skip = perc>options.maxperc or avg>options.maxavg

        print "%-1s %s: %5.2f %5.2f: %s"%("*" if skip else "",fname,perc,avg,result)

        cseg_file = ocrolib.fvariant(fname,"cseg",options.suffix)
        if not options.overwrite:
            if os.path.exists(cseg_file): die("%s: already exists",cseg_file)

        ocrolib.write_line_segmentation(cseg_file,cseg)
        ocrolib.write_text(ocrolib.fvariant(fname,"txt",options.suffix),result)
        with ocrolib.fopen(fname,"costs",options.suffix,mode="w") as stream:
            for i in range(len(costs)):
                stream.write("%d %g\n"%(i,costs[i]))
    except IOError,e:
        print "# not found:",e

jobs = []

if options.pagegt is not None:
    for arg in args:
        if not os.path.exists(arg):
            print "# %s: not found"%arg
            continue
        base,_ = ocrolib.allsplitext(arg)
        if not os.path.exists(base):
            print "# %s: base dir not found"%base
            continue
        if not os.path.isdir(base):
            print "# %s: not a directory"%base
            continue
        lines = glob.glob(base+"/??????.png")
        for line in lines:
            jobs.append((line,arg))
elif options.langmod is not None:
    for arg in args:
        jobs.append((arg,options.langmod))
elif options.gt is not None:
    for arg in args:
        path,ext = ocrolib.allsplitext(arg)
        p = path+options.gt
        if not os.path.exists(arg):
            print arg,"not found"
            continue
        if not os.path.exists(p): 
            print p,"not found"
            continue
        jobs.append((arg,p))
else:
    raise Exception("you need to specify what kind of groundtruth you want to align with (-p, -l, -g)")

if options.parallel<2:
    for arg in jobs: align1(arg)
else:
    pool = Pool(processes=options.parallel)
    result = pool.map(safe_align1,jobs)
