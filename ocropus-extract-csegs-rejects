#!/usr/bin/python
import code,pickle,sys,os,re,traceback
from optparse import OptionParser
from pylab import *
import ocropy
from ocropy import dbtables,ocrobook,Record

parser = OptionParser("""
usage: %prog [options] .../.../010001.png ...

Extract character images from OCR output and store them in a database file.  
This assume that for each line.png, there is a line.cseg.gt.png and line.gt.txt file.
""")

parser.add_option("-o","--output",help="output file",default="chars.db")
parser.add_option("-u","--unmerged",help="unmerged output file",default=None)
parser.add_option("-m","--missegmented",help="output missegmented characters",action="store_true")
parser.add_option("-r","--raw",help="output unlabeled characters",action="store_true")
parser.add_option("-a","--maxage",help="output missegmented",default=10000000,type="int")

parser.add_option("-D","--display",help="display chars",action="store_true")
parser.add_option("-v","--verbose",help="verbose output",action="store_true")
parser.add_option("-S","--nosource",help="do not record source info",action="store_true")
parser.add_option("-O","--overlap",help="max overlap acceptable for rejects",default=0.5,type="float")

(options,args) = parser.parse_args()

if len(args)<1:
    parser.print_help()
    sys.exit(0)

ion()
show()

if os.path.exists(options.output):
    print options.output,"exists; please remove"
    sys.exit(1)

def rect(r):
    return (r.x0,r.y0,r.x1,r.y1)

def load_chars(png_file):
    grouper = ocropy.make_IGrouper("SimpleGrouper")
    grouper.pset("maxrange",1)

    image = ocropy.bytearray()
    ocropy.read_image_gray(image,png_file)

    cseg_file = re.sub(r'\.png','.cseg.gt.png',png_file)
    cseg = ocropy.intarray()
    ocropy.read_image_packed(cseg,cseg_file)
    ocropy.make_line_segmentation_black(cseg)

    rseg_file = re.sub(r'\.png','.rseg.gt.png',png_file)
    rseg = ocropy.intarray()
    ocropy.read_image_packed(rseg,rseg_file)
    ocropy.make_line_segmentation_black(rseg)

    text_file = re.sub(r'\.png','.gt.txt',png_file)
    text = open(text_file).read()
    if text[-1]=="\n": text = text[:-1]
    if len(text)>ocropy.max(cseg):
        text = re.sub(r'\s+','',text)
    utext = ocropy.ustrg()
    utext.assign(text) # FIXME should do UTF8 or u""

    # invert the image, since that's the way we're doing all remaining processing
    ocropy.sub(255,image)

    # now iterate through the csegs of the line
    grouper = ocropy.make_IGrouper("SimpleGrouper")
    grouper.setSegmentationAndGt(rseg,cseg,utext)
    chars = []
    for i in range(grouper.length()):

        # just add everything to the list of characters
        cls = grouper.getGtClass(i)

        # the grouper will also return unaligned groups; we ignore
        # them here, since we explicitly process these in the next loop
        if cls==-1: continue

        # now put all good characters from cseg into the chars list
        cls = chr(cls)
        raw = ocropy.bytearray()
        mask = ocropy.bytearray()
        grouper.extractWithMask(raw,mask,image,i,1)
        chars.append(Record(raw=raw,mask=mask,cls=cls,index=i,bbox=grouper.boundingBox(i)))

    bboxes = [rect(c.bbox) for c in chars]
    
    # now iterate through the rsegs of the line
    grouper = ocropy.make_IGrouper("SimpleGrouper")
    grouper.setSegmentation(rseg)
    nonchars = []
    for i in range(grouper.length()):

        cls = -1

        # check whether the rseg box overlaps strongly with a character;
        # if so, don't add it as a missegmentation
        bbox = grouper.boundingBox(i)
        fractions = [min(bbox.fraction_covered_by(c.bbox),c.bbox.fraction_covered_by(bbox)) for c in chars]
        covered = max(fractions)

        # all grouped rsegs should overlap at least some true character significantly
        if covered<1e-5:
            print "# warning: uncovered rseg",covered
            continue
        if covered>options.overlap: continue

        # just a sanity check
        assert rect(bbox) not in bboxes

        # debugging code
        if 0: 
            j = argmax(fractions)
            print "match",j,chars[j].cls,rect(bbox),rect(chars[j].bbox),covered
            cls = "~%s:%g"%(chars[j].cls,covered) # stick the info into the class for debugging

        # extract the image and the rest and add it to the list of non-characters
        raw = ocropy.bytearray()
        mask = ocropy.bytearray()
        grouper.extractWithMask(raw,mask,image,i,1)
        nonchars.append(Record(raw=raw,mask=mask,cls=cls,index=i,bbox=grouper.boundingBox(i)))

    return chars,nonchars

table = dbtables.Table(options.output,"chars")
table.converter("image",dbtables.SmallImage())
table.create(image="blob",cls="text",file="text",segid="integer",bbox="text",count="integer",classes="text")

ntried = 0
nfiles = 0
total = 0
for file in args:
    segments = []
    text = ""
    ntried += 1
    if not os.path.exists(re.sub(r'.png$','.rseg.gt.png',file)):
        if not os.path.exists(re.sub(r'.png$','.cseg.gt.png',file)): 
            print "# skipping",file,"(no rseg)"
            continue
        print "# no rseg but has cseg??? skipping...",file
        continue
    try:
        chars,nonchars = load_chars(file)
        nfiles += 1
    except:
        traceback.print_exc()
        print "#",file,"failed"
        continue
    if options.missegmented:
        items = chars + nonchars
    else:
        items = chars
        # for c in chars: print c.cls
    if options.verbose:
        print file,len(segments),len(text)
    for x in items:
        raw = x.raw
        mask = x.mask
        cls = x.cls
        segments.append(raw)
        if options.display:
            clf(); gray(); imshow(ocrobook.NI(raw)); draw()
        if cls is None:
            # no ground truth
            if not options.raw: continue
            cls = "_"
        elif cls==-1 or cls=="":
            # missegmented
            if not options.missegmented: continue
            cls = "~"
        else:
            text += cls
        raw = ocrobook.NI(raw)
        if raw.shape[0]>255 or raw.shape[1]>255: continue
        raw = raw/float(amax(raw))
        key = re.sub(r'^.*/(\d\d\d\d/)','\\1',file)
        key = re.sub(r'\.png$','',key)
        if options.verbose:
            print key,cls,raw.shape
        if options.nosource:
            id = table.set(image=raw,cls=cls,count=1)
        else:
            r = x.bbox
            id = table.set(image=raw,cls=cls,count=1,
                           file=file,
                           bbox="%d %d %d %d"%(r.x0,r.y0,r.x1,r.y1))
        if options.display:
            clf(); title("%s"%x.cls); gray(); imshow(ocrobook.NI(raw)); draw()
            raw_input()
        total+=1
        if total%10000==0:
            print total,"chars"
            table.commit()

table.commit()
print total,"chars"
