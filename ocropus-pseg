#!/usr/bin/python

import signal
signal.signal(signal.SIGINT,lambda *args:sys.exit(1))
import sys,os,re,optparse,shutil
from matplotlib import patches
from pylab import *
from scipy.stats.stats import trim1
from multiprocessing import Pool
from scipy.ndimage import measurements
from scipy.misc import imsave

from ocrolib import number_of_processors
import ocrolib as common

parser = optparse.OptionParser(usage="""
%prog [options] image1.png image2.png ...

Usually, you would use an argument pattern like: book/????/??????.png

Computes page segmentations and extracts text lines.
For each input image image.png, it generates:

* image.pseg.png -- page segmentation
* image/010001.png -- gray scale text line image column 1, line 1
* image/010001.bin.png -- bineary text line image column 1, line 1

Use the -d or -D argument to verify that the layout analysis is working
correctly.

If image.bin.png exists, it uses it.  If not, it uses built-in
preprocessing and generates and writes its own binary version.
(The original gray scale image is, however, not altered, so it
may be rotated relative to the binary image.)

If an image.tiseg.png file exists, it uses it to constrain the
layout analysis (although some layout analysis methods may be
ignoring the map).
""")
parser.add_option("-g","--gray",action="store_true",
                  help="output grayscale images + binary masks")
parser.add_option("-p","--pad",default=1,type=int,
                  help="pad lines by this amount")
parser.add_option("-d","--display",action="store_true",
                  help="display result")
parser.add_option("-D","--Display",action="store_true",
                  help="display continuously")
parser.add_option("-S","--segmenter",default="SegmentPageByRAST",
                  help="which segmentation component to use")
parser.add_option("-P","--preproc",default="StandardPreprocessing",
                  help="which preprocessing component to use")
parser.add_option("-r","--dpi",default=300,type=int,
                  help="resolution of input image in DPI")
parser.add_option("-q","--silent",action="store_true",
                  help="disable warnings")
parser.add_option("-b","--blackout",action="store_false",default=True,
                  help="use blackout for image regions (instead of passing rectangles)")
parser.add_option("-R","--descender",type=float,default=-1,
                  help="maximum descender")
parser.add_option("-Q","--parallel",type=int,default=number_of_processors(),
                  help="number of parallel processes to use")
options,args = parser.parse_args()


preproc = common.Binarize().make(options.preproc)
segmenter = common.SegmentPage().make(options.segmenter)
if options.descender>0:
    segmenter.pset("max_descender",options.descender)

if options.Display: options.display = 1
if options.display: ion()

def process_arg(arg):
    print "===",arg
    base,_ = common.allsplitext(arg)
    image = common.read_image_gray(arg,'B')
    h,w = image.shape

    if options.display:
        clf(); imshow(image,cmap=cm.gray); draw(); ginput(1,1)

    # get a binary image, either saved on disk or through
    # preprocessing
    if os.path.exists(base+".bin.png"):
        print "# loading",base+".bin.png"
        page_gray = image
        page_bin = common.read_image_gray(base+".bin.png")
    else:
        print "# binarizing"
        (page_bin,page_gray) = preproc.binarize(image)
        common.write_image_gray(base+".bin.png",page_bin)

    # get a text/image segmentation if available
    page_ti = None
    tirects = None
    if os.path.exists(base+".tiseg.png"):
        # FIXME
        print "# loading",base+".tiseg.png"
        ocropy.read_image_packed(page_ti,base+".tiseg.png")
        r = ocropy.bytearray()
        g = ocropy.bytearray()
        b = ocropy.bytearray()
        ocropy.unpack_rgb(r,g,b,page_ti)
        components = ocropy.intarray()
        components.copy(g)
        n = ocropy.label_components(components)
        print "# number of image regions",n
        ocropy.bounding_boxes(tirects,components)

    if options.blackout and tirects is not None:
        for (r0,c0,r1,c1) in tirects:
            page_bin[r0:r1,c0:c1] = 0

    if options.display:
        clf(); imshow(page_bin,cmap=cm.gray); draw(); ginput(1,1)

    print "# segmenting"
    if options.blackout:
        page_seg = segmenter.segment(page_bin)
    else:
        page_seg = segmenter.segment(page_bin,tirects)
    regions = common.RegionExtractor()
    regions.setPageLines(page_seg)
    if os.path.exists(base):
        print "# removing",base
        shutil.rmtree(base)
    os.mkdir(base)

    nregions = regions.length()
    print "# writing",nregions,"lines"
    if options.display:
        clf()
        axis = subplot(111)
        axis.imshow(page_bin,cmap=cm.gray)
        common.draw_pseg(page_seg,axis)

    for i in range(1,regions.length()):
        line = regions.extractMasked(page_bin,i,0,255,options.pad)
        if not options.silent:
            if common.quick_check_line_components(line,dpi=options.dpi)<0.5:
                continue
        if options.gray:
            common.write_image_gray("%s/%06x.bin.png"%(base,regions.id(i)),line)
            line = regions.extract(page_gray,i,options.pad)
            common.write_image_gray("%s/%06x.png"%(base,regions.id(i)),line)
        else:
            common.write_image_gray("%s/%06x.bin.png"%(base,regions.id(i)),line)
            common.write_image_gray("%s/%06x.png"%(base,regions.id(i)),line)
    common.write_page_segmentation(base+".pseg.png",page_seg)
    try:
        pass
    except:
        print "# OOPS bad page segmentation?"
    if options.display:
        draw()
        if not options.Display: 
            raw_input("hit ENTER to continue")
        else:
            ginput(1,timeout=1)

if options.parallel<2:
    for arg in args:
        process_arg(arg)
else:
    pool = Pool(processes=options.parallel)
    jobs = args
    result = pool.map(process_arg,jobs)
