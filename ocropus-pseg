#!/usr/bin/python

import signal
signal.signal(signal.SIGINT,lambda *args:sys.exit(1))
import sys,os,re,optparse,shutil
from matplotlib import patches
from pylab import *
from scipy.stats.stats import trim1

from scipy.ndimage import measurements
from scipy.misc import imsave
from PIL import Image
import ocropy
from ocropy import N,NI,plotutils

parser = optparse.OptionParser(usage="""
%prog [options] image1.png image2.png ...

Usually, you would use an argument pattern like: book/????/??????.png

Computes page segmentations and extracts text lines.
For each input image image.png, it generates:

* image.pseg.png -- page segmentation
* image/010001.png -- gray scale text line image column 1, line 1
* image/010001.bin.png -- bineary text line image column 1, line 1

Use the -d or -D argument to verify that the layout analysis is working
correctly.

If image.bin.png exists, it uses it.  If not, it uses built-in
preprocessing and generates and writes its own binary version.
(The original gray scale image is, however, not altered, so it
may be rotated relative to the binary image.)

If an image.tiseg.png file exists, it uses it to constrain the
layout analysis (although some layout analysis methods may be
ignoring the map).
""")
parser.add_option("-g","--gray",action="store_true",
                  help="output grayscale images + binary masks")
parser.add_option("-p","--pad",default=1,type=int,
                  help="pad lines by this amount")
parser.add_option("-d","--display",action="store_true",
                  help="display result")
parser.add_option("-D","--Display",action="store_true",
                  help="display continuously")
parser.add_option("-S","--segmenter",default="SegmentPageByRAST",
                  help="which segmentation component to use")
parser.add_option("-P","--preproc",default="StandardPreprocessing",
                  help="which preprocessing component to use")
parser.add_option("-r","--dpi",default=300,type=int,
                  help="resolution of input image in DPI")
parser.add_option("-q","--silent",action="store_true",
                  help="disable warnings")
parser.add_option("-b","--blackout",action="store_false",default=True,
                  help="use blackout for image regions (instead of passing rectangles)")
options,args = parser.parse_args()


preproc = ocropy.make_IBinarize(options.preproc)
segmenter = ocropy.make_ISegmentPage(options.segmenter)

if options.Display: options.display = 1
if options.display: ion()

for arg in args:
    print
    print "===",arg,"==="
    print
    base,_ = ocropy.allsplitext(arg)
    image = ocropy.bytearray()
    ocropy.read_image_gray(image,arg)
    w,h = [image.dim(i) for i in [0,1]]

    if options.display:
        clf(); imshow(NI(image),cmap=cm.gray); draw(); ginput(1,1)

    # get a binary image, either saved on disk or through
    # preprocessing
    page_bin = ocropy.bytearray()
    if os.path.exists(base+".bin.png"):
        print "# loading",base+".bin.png"
        page_gray = image
        ocropy.read_image_gray(page_bin,base+".bin.png")
    else:
        print "# binarizing"
        page_gray = ocropy.bytearray()
        preproc.binarize(page_bin,page_gray,image)
        ocropy.write_image_gray(base+".bin.png",page_bin)

    # get a text/image segmentation if available
    page_ti = ocropy.intarray()
    tirects = ocropy.rectarray()
    if os.path.exists(base+".tiseg.png"):
        print "# loading",base+".tiseg.png"
        ocropy.read_image_packed(page_ti,base+".tiseg.png")
        r = ocropy.bytearray()
        g = ocropy.bytearray()
        b = ocropy.bytearray()
        ocropy.unpack_rgb(r,g,b,page_ti)
        components = ocropy.intarray()
        components.copy(g)
        n = ocropy.label_components(components)
        print "# number of image regions",n
        ocropy.bounding_boxes(tirects,components)

    if options.blackout:
        for i in range(1,tirects.length()):
            r = tirects.at(i)
            ocropy.fill_rect(page_bin,r,0)

    if options.display:
        clf(); imshow(NI(page_bin),cmap=cm.gray); draw(); ginput(1,1)

    print "# segmenting"
    page_seg = ocropy.intarray()
    if options.blackout:
        segmenter.segment(page_seg,page_bin)
    else:
        segmenter.segment(page_seg,page_bin,tirects)
    regions = ocropy.RegionExtractor()
    regions.setPageLines(page_seg)
    if os.path.exists(base):
        print "# removing",base
        shutil.rmtree(base)
    os.mkdir(base)

    print "# writing",regions.length(),"lines"
    if options.display:
        clf()
        axis = subplot(111)
        axis.imshow(NI(page_bin),cmap=cm.gray)
        plotutils.draw_pseg(page_seg,axis)

    line = ocropy.bytearray()
    for i in range(1,regions.length()):
        regions.extract_masked(line,page_bin,i,0,255,options.pad)
        if not options.silent:
            if ocropy.quick_check_line_components(line,dpi=options.dpi)<0.5:
                continue
        if options.gray:
            ocropy.write_image_gray("%s/%06x.bin.png"%(base,regions.id(i)),line)
            regions.extract(line,page_gray,i,options.pad)
            ocropy.write_image_gray("%s/%06x.png"%(base,regions.id(i)),line)
        else:
            ocropy.write_image_gray("%s/%06x.png"%(base,regions.id(i)),line)
    try:
        ocropy.make_page_segmentation_white(page_seg)
        ocropy.write_image_packed(base+".pseg.png",page_seg)
    except:
        print "# OOPS bad page segmentation?"
        ocropy.write_image_packed(base+".BAD-pseg.png",page_seg)
    if options.display:
        draw()
        if not options.Display: 
            raw_input("hit ENTER to continue")
        else:
            ginput(1,timeout=1)
