#!/usr/bin/python
import random as pyrandom
import code,pickle,sys,os,re,traceback,cPickle
from optparse import OptionParser
from pylab import *
from scipy import stats
import ocrolib
from ocrolib import dbtables,quant

input = "unlv.db"
#input = "chars.db"
table = "chars"
output = "unlv-multi-model"
overlap = 6
nsample = 50000
kmeans = 225
minsamples = 20

os.system("rm -rf "+output)
os.mkdir(output)

ion()

db = dbtables.CharDB(input,table)

extractor = ocrolib.ScaledFE()
def extract(v):
    v /= sqrt(sum(v**2))
    v = extractor.extract(v)
    return v

def getdata(db,ids):
    classes = []
    images = []
    for id in ids:
        row = db[id]
        images.append(extract(row.float_image()).ravel())
        classes.append(row.cls)
    return array(images,'f'),classes

def plotgrid(data,d=10,shape=(30,30)):
    ion()
    gray()
    clf()
    for i in range(min(d*d,len(data))):
        subplot(d,d,i+1)
        row = data[i]
        if shape is not None: row = row.reshape(shape)
        imshow(row)
    ginput(1,timeout=1)

def chist(l):
    counts = {}
    for c in l:
        counts[c] = counts.get(c,0)+1
    hist = [(v,k) for k,v in counts.items()]
    return sorted(hist,reverse=1)

ids = db.keys()
sample = ids
if len(ids)>nsample: sample = pyrandom.sample(ids,nsample)

print "# loading data"
data = getdata(db,sample)[0]
plotgrid(data)

print "# kmeans"
means,counts = quant.kmeans(data,k=kmeans)
plotgrid(means)

with open(output+"/clusters","w") as stream:
    cPickle.dump(means,stream,2)

print "# computing distances"
distances = [[] for i in range(len(means))]
ids = [[] for i in range(len(means))]
total = 0
for id in db.keys():
    row = db[id]
    image = extract(row.float_image())
    ds = quant.alldists(image.ravel(),means)
    js = argsort(ds)
    if total%1000==0: print "#",total,js[:2],ds[:2]
    for i in range(overlap):
        distances[js[i]].append(ds[js[i]])
        ids[js[i]].append(row.id)
    total += 1

print "# training"
models = [None] * len(ids)
for block in range(len(ids)):
    data,classes = getdata(db,ids[block])
    print "# got",len(data)
    ch = chist(classes)
    counts = {}
    for c,k in ch: counts[k] = c
    ch = [l for l in ch if l[0]>minsamples]
    if len(ch)<2:
        print "# only one significant class; skipping"
        continue
    print "# total",len(classes),"hist",ch
    model = ocrolib.AutoMlpClassifier()
    for id in ids[block]:
        row = db[id]
        image = extract(row.float_image())
        params = row.rel_lineparams()
        v = concatenate([image.ravel(),params])
        if counts[row.cls]<minsamples: continue
        model.cadd(v,row.cls)
    try:
        model.updateModel()
    except:
        traceback.print_exc()
        continue
    models[i] = model
    ocrolib.save_component(output+"/%06d.model"%block,model)

combined = (means,models)
with open(output+".pymodel","w") as stream:
    cPickle.dump(combined,stream,2)
