#!/usr/bin/python

import sys,os,re,glob,math,glob,signal
from optparse import OptionParser
from pylab import *
from scipy.ndimage import interpolation,filters
import ocropy
from ocropy import dbtables
from ocropy import N,NI,F,FI
signal.signal(signal.SIGINT,lambda *args:sys.exit(1))

parser = OptionParser(usage="""
%prog [options] input.db output.model

Trains models based on a cluster database.

For faster speed and better memory usage, use the "-b" option, which buffers
samples in a 1bpp buffer (only binary input patterns).

You can choose different kinds of feature extractors with the -E flag.  
Some possible values are: scaledfe (raw grayscale image rescaled to a target size) 
and biggestcc (biggest connected component only, otherwise treated like scaledfe).
You can find additional components by running "ocropus components" and looking for
implementors of IExtractor.
""")
parser.add_option("-m","--model",help="IModel name",default="latin")
parser.add_option("-b","--bits",help="buffer training data with 1 bpp",action="store_true")
parser.add_option("-t","--table",help="database table to use for training",default="chars")
parser.add_option("-r","--reject",help="disable reject",action="store_false",default=True)
parser.add_option("-u","--unlabeled",help="treat unlabeled ('_') as reject",action="store_true")
parser.add_option("-1","--single",help="train only single chars",action="store_true")
parser.add_option("-v","--verbose",help="verbose",action="store_true")
parser.add_option("-E","--extractor",help="feature extractor",default="scaledfe")
parser.add_option("-N","--nvariants",help="number of variants to generate",default=0,type="int")
parser.add_option("-D","--distortion",help="maximum distortion",default=0.2,type="float")
parser.add_option("-d","--debug",help="debug display",action="store_true")
(options,args) = parser.parse_args()

if len(args)!=2:
    parser.print_help()
    sys.exit(0)

db = args[0] # "unlv-clusters-0684.db"
output = args[1]

print "loading..."
table = dbtables.ClusterTable(db,name=options.table)
clusters = table.get()

ion()

classifier = ocropy.make_IModel(options.model)
classifier.setExtractor(options.extractor)
if options.bits:
    classifier.pset("cds","bitdataset")
ocropy.dinit(512,512)

def pad(image,dx,dy,bgval=None):
    if bgval is None: bgval = amin(image)
    h,w = image.shape
    result = zeros((h+2*dx,w+2*dy))
    result[:,:] = bgval
    result[dx:-dx,dy:-dy] = image
    return result

def distort(nimage,sx,sy,sigma=10.0,debug=0):
    if debug: clf(); gray()
    image = NI(nimage)
    h0,w0 = image.shape
    my = sy*h0
    mx = sx*w0
    image = pad(image,int(my+1),int(mx+1))
    if debug: subplot(141); imshow(image)
    h,w = image.shape
    dy = filters.gaussian_filter(rand(*image.shape)-0.5,sigma)
    dy *= my/amax(abs(dy))
    dx = filters.gaussian_filter(rand(*image.shape)-0.5,sigma)
    dx *= mx/amax(abs(dx))
    if debug: subplot(142); imshow(dy.copy())
    if debug: subplot(143); imshow(dx.copy())
    dy += arange(h)[:,newaxis]
    dx += arange(w)[newaxis,:]
    distorted = interpolation.map_coordinates(image,array([dy,dx]),order=1)
    if debug: subplot(144); imshow(distorted); draw(); raw_input()
    return FI(distorted)

print "training..."
# clusters = list(clusters)
# print len(clusters)
count = 0
for cluster in clusters:
    cls = cluster.cls
    if cls is None: continue
    if len(cls)==0: continue
    if len(cls)>3: continue
    if options.single and len(cls)>1: continue
    if options.unlabeled and cls=="_": cls = "~"
    if not options.reject and cls=="~": continue
    if cls=="_": continue
    image = FI(cluster.image/255.0)
    classifier.cadd(image,cls)
    count += 1
    for i in range(options.nvariants):
        sx = options.distortion
        sy = options.distortion
        classifier.cadd(distort(image,sx,sy,debug=options.debug),cls)
        count += 1
    if count%10000==0: print count

classifier.updateModel()
classifier.info()
classifier.getExtractor().info()
ocropy.save_component(output,classifier)
