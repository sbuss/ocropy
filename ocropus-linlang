#!/usr/bin/python

################################################################
### Align transcriptions with lattices.
################################################################

import sys,os,re,glob,math,glob,signal,traceback,sqlite3
import matplotlib
if "DISPLAY" not in os.environ: matplotlib.use("AGG")
else: matplotlib.use("GTK")
from scipy.ndimage import interpolation,measurements
from pylab import *
from optparse import OptionParser
from multiprocessing import Pool
import ocrolib
from ocrolib import number_of_processors,fstutils,die,docproc
from scipy import stats
from ocrolib import dbhelper,ocroio,ocrofst
from ocrolib import ligatures,rect_union,Record
import multiprocessing

signal.signal(signal.SIGINT,lambda *args:sys.exit(1))

import argparse
parser = argparse.ArgumentParser(description = """
%prog [-s gt] [-p] [args] *.gt.txt
""")

parser.add_argument("-x","--extract",help="extract characters",default=None)
parser.add_argument("-X","--noextract",help="don't actually write files",action="store_true")
parser.add_argument("-N","--normalize",help="size normalize characters",action="store_true")
parser.add_argument("-B","--beam",help="size of beam",type=int,default=100)
parser.add_argument("-T","--confusions",help="confusion table (lattice output cost)",default=None)
parser.add_argument("-r","--rejects",help="save rejects as well",action="store_true")

parser.add_argument("-f","--filelist",help="list of images and langmods",default=None)
parser.add_argument("-g","--gt",help="extension for ground truth",default=None)
parser.add_argument("-p","--pagegt",help="arguments are page ground truth",action="store_true")
parser.add_argument("--ppat",default=".*",help="file pattern to match with -p")
parser.add_argument("-l","--langmod",help="language model",default=None)

parser.add_argument("-s","--suffix",help="output suffix for writing result",default=None)
parser.add_argument("-O","--overwrite",help="overwrite outputs",action="store_true")

parser.add_argument("-P","--perc",help="percentile for reporting statistics",type=float,default=90.0)
parser.add_argument("-M","--maxperc",help="maximum cost at percentile",type=float,default=5.0)
parser.add_argument("-A","--maxavg",help="maximum average cost",type=float,default=5.0)
parser.add_argument("--minlength",help="minimum length for alignment",type=int,default=10)

parser.add_argument("-c","--mmcost",help="mismatch cost",type=float,default=3.0)
parser.add_argument('-R','--rcost',help="single character mismatch threshold",type=float,default=8.0)
parser.add_argument('--lcost2',help="ligature cost",type=float,default=2.0)
parser.add_argument('--lcost3',help="ligature cost",type=float,default=3.0)
parser.add_argument("-C","--edcost",help="edit cost",type=float,default=9.0)
parser.add_argument("--trimcost",help="cost for removing characters at beginning/end",default=2.0)
parser.add_argument("--maxtrim",help="maximum number of chars permitted to be trimmed",default=1)
parser.add_argument("--maxlig",help="maximum number of ligatures on line",default=2)

parser.add_argument("-Q","--parallel",type=int,default=multiprocessing.cpu_count(),help="number of parallel processes to use")

parser.add_argument("-D","--Display",help="display",action="store_true")
parser.add_argument("--debug_line",action="store_true")
parser.add_argument("--debug_rawalign",action="store_true")
parser.add_argument("--debug_aligned",action="store_true")
parser.add_argument("--debug_select",action="store_true")
parser.add_argument('--dgrid',default=8,help="grid size for display")
parser.add_argument('--nlines',default=999999999,type=int,help="max # lines to process (for testing)")

parser.add_argument("args",default=[],nargs='*',help="input lines)")
# args = parser.parse_args(["-D","-y","-x","temp.db"])
args = parser.parse_args()
args.args = sorted(concatenate([glob.glob(x) for x in args.args]))
print "got",len(args.args),"files"

# a list of confusions and their costs
# format is classifier output and actual output

confusions = []

if args.confusions is not None:
    with open(args.confusions) as stream:
        for line in stream.readlines():
            f = line.split()
            assert len(f)==3
            confusions.append((f[0],f[1],float(f[2])))

class LigTable:
    """Ligature encoding table.  These ligatures are used just locally within
    the aligner.  No data is actually stored in this format."""
    def __init__(self,init=1):
        self.ncodes = 0
        self.code2chr = {}
        self.chr2code = {}
        if init:
            for i in range(128):
                self.ord(unichr(i))
    def ord(self,c):
        if c in self.chr2code: 
            return self.chr2code[c]
        code = self.ncodes
        self.ncodes += 1
        self.code2chr[code] = c
        self.chr2code[c] = code
        return code
    def chr(self,c):
        return self.code2chr[c]

ltable = LigTable()

print repr(args.extract)
if args.extract is not None:
    assert not os.path.exists(args.extract),"%s: already exists; please remove"%args.extract

from tables import *
import tables

def uencode(s):
    """Convert a short unicode string into a 64bit integer"""
    assert len(s)<=4
    result = 0
    for c in s[len(s)-1::-1]: result = (result<<16)|ord(c)
    return result

class Hdf5Writer:
    def __init__(self,fname,mode="w",size=(32,32)):
        self.size = tuple(size)
        self.h5 = None
        self.fname = fname
        self.mode = mode
    def flush(self):
        if self.h5 is not None:
            self.h5.flush()
    def open(self):
        h5 = tables.openFile(self.fname,self.mode)
        if "patches" not in dir(h5.root):
            h5.createEArray(h5.root,'patches',Float32Atom(),shape=(0,self.size[0],self.size[1]),filters=Filters(9))
            h5.createEArray(h5.root,'classes',Int64Atom(),shape=(0,),filters=tables.Filters(9))
        self.h5 = h5
    def close(self):
        self.h5.close()
        self.h5 = None
    def insert(self,image,cls):
        if self.h5 is None:
            self.size = image.shape
            self.open()
        else:
            assert image.shape==self.size,"wrong image shape: %s"%(image.shape,)
        h5 = self.h5
        h5.root.patches.append([image])
        h5.root.classes.append([uencode(cls)])
    def __enter__(self):
        return self
    def __exit__(self,*args):
        self.close()

import codecs
import openfst
from ocrolib.fstutils import explode_transcription,epsilon,space,sigma,add_between,optimize_openfst,openfst2ocrofst

def alignment_fst(line):
    fst = ocrofst.OcroFST()
    state = fst.AddState()
    fst.SetStart(state)
    states = [state]
    for i in range(len(line)):
        states.append(fst.AddState())
    ntrim = min(len(line)/4,args.maxtrim)
    for i in range(ntrim):
        fst.AddArc(states[i],epsilon,ord("~"),args.trimcost,states[i+1])
    for i in range(len(line)-ntrim,len(line)):
        fst.AddArc(states[i],epsilon,ord("~"),args.trimcost,states[i+1])
    for i in range(len(line)):
        s = line[i]
        c = ord(s)
        start = states[i]
        next = states[i+1]

        # space is special (since we use separate skip/insertion self)

        # insertion of space
        fst.AddArc(next,space,space,0.0,next)
        # insertion of other character
        fst.AddArc(start,sigma,ord("~"),args.edcost,start)

        if s==" ":
            # space transition
            fst.AddArc(start,space,space,0.0,next)
            # skip space
            fst.AddArc(start,epsilon,space,0.0,next)
            continue

        if s in ["~","_"]:
            # common ground-truth indicators of errors, unrecognizable characters
            fst.AddArc(start,sigma,ord("~"),4.0,start) # also allow repetition with some cost
            fst.AddArc(start,sigma,ord("~"),0.0,next)
            continue

        # add character transition
        fst.AddArc(start,c,c,0.0,next)
        # mismatch between input and transcription
        fst.AddArc(start,sigma,ord("_"),args.rcost,next)
        # deletion in lattice
        fst.AddArc(start,epsilon,ord("~"),args.edcost,next)
        # insertion in lattice
        fst.AddArc(start,sigma,epsilon,args.edcost,next)

    # explicit transition for confusions; note that multi-character
    # outputs are always treated as ligatures

    for i in range(0,len(line)):
        for u,v,cost in confusions:
            if i+len(v)>len(line): continue
            if line[i:i+len(v)]==v:
                start = states[i]
                end = states[i+len(v)]
                for j in range(len(u)-1):
                    next = fst.AddState()
                    fst.AddArc(start,ord(u[j]),epsilon,0.0,next)
                    start = next
                fst.AddArc(start,ord(u[-1]),ltable.ord(v),cost,end)

    # explicit transitions for ligatures: use epsilon on input, use encoded ligatures on output,

    if args.lcost2<inf:
        for i in range(0,len(line)-2):
            s = line[i:i+2]
            if " " in s: continue
            start = states[i]
            catch = fst.AddState()
            fst.AddArc(start,ord("~"),ltable.ord(s),0.0,catch)
            fst.AddArc(start,sigma,ltable.ord(s),args.lcost2,catch)
            fst.AddArc(catch,ord(line[i+2]),ord(line[i+2]),0.0,states[i+3])

    if args.lcost3<inf:
        for i in range(0,len(line)-3):
            s = line[i:i+3]
            if " " in s: continue
            start = states[i]
            catch = fst.AddState()
            fst.AddArc(start,ord("~"),ltable.ord(s),0.0,next)
            fst.AddArc(start,sigma,ltable.ord(s),args.lcost3,next)
            fst.AddArc(catch,ord(line[i+3]),ord(line[i+3]),0.0,states[i+4])

    last = states[-1]
    fst.AddArc(last,sigma,epsilon,args.edcost,last)
    fst.SetFinal(last,0.0)
    # print line; fst.save("_aligner.fst"); sys.exit(0)
    return fst

debug = 0
niclasses = 128
iclasses = LigTable(init=0)
iclasses.ord(chr(0))
for c in ["~D","~U","~L"]: iclasses.ord(c)
for i in range(32,128): iclasses.ord(unichr(i))
    
def transitions(lattice):
    # print lattice.nStates()
    for frm in range(lattice.nStates()):
        tos,outs,costs,ins = lattice.getTransitions(frm)
        for j in range(len(tos)):
            yield (frm,tos[j],ins[j],outs[j],costs[j])

def lattice2image(lattice,rf=0.2):
    maxseg = amax([i&0xffff for f,t,i,o,c in transitions(lattice)])
    simage = zeros((maxseg+1,niclasses))
    # print "lattice2image",
    for f,t,i,o,c in transitions(lattice):
        a = (i>>16)
        b = (i&0xffff)
        oc = unichr(o)
        o = iclasses.ord(oc)
        if o>=niclasses: continue
        c = exp(-c)
        if a==0 and b==0: continue
        # print f,t,i,o,c,(a,b)
        simage[a:b+1,o] = maximum(simage[a:b+1,o],rf*c)
        simage[a,o] = maximum(simage[a,o],c)
    # provide some context, but scale it back so that it doesn't affect the nn too much
    for a in range(len(simage)):
        simage[a,iclasses.ord("~D")] = 0.2*amax(simage[a,iclasses.ord("0"):iclasses.ord("9")+1])
    for a in range(len(simage)):
        simage[a,iclasses.ord("~U")] = 0.2*amax(simage[a,iclasses.ord("A"):iclasses.ord("Z")+1])
    for a in range(len(simage)):
        simage[a,iclasses.ord("~L")] = 0.2*amax(simage[a,iclasses.ord("a"):iclasses.ord("z")+1])
    return simage

h5output = Hdf5Writer("linlang.h5")

count = 0

def align1(job):
    global count
    fname,gtfile = job
    # read the ground truth data and construct an FST
    if not os.path.exists(gtfile):
        print "*"+gtfile,": NOT FOUND"
        return
    with open(gtfile) as stream:
        gttext = stream.read()[:-1]
    gttext = re.sub("[\001-\011\013-\037]","~",gttext)

    fst_file = ocrolib.fvariant(fname,"fst")
    if not os.path.exists(fst_file):
        print "*"+fst_file,": NOT FOUND"
        return
    fst = ocrofst.OcroFST()
    try: fst.load(fst_file)
    except:
        print "*"+fst_file,": load failed"
        return

    bestcost = 1e38
    bestline = None
    bestfst = None
    best = None
    for i,line in enumerate(gttext.split("\n")):
        line = line.strip()
        line = re.sub(r'[~_ \t]+',' ',line)
        if len(line)<=1: continue
        gtfst = alignment_fst(line)
        # actually perform the alignment
        result = ocrofst.beam_search(fst,gtfst,100)
        if args.debug_line:
            print "line",i,len(result[0]),sum(result[4])
        if len(result[0])<=1: continue
        avg = sum(result[4])/len(result[0]+10.0)
        if avg>=bestcost: continue
        bestcost = avg
        bestline = line
        bestfst = gtfst
        best = result

    if best is None:
        print "*"+fst_file,gtfile,": BEAM SEARCH FAILED"
        return

    if len(bestline)<args.minlength:
        print "*"+fst_file,": SHORT/%d"%len(bestline)
        return

    v1,v2,ins,outs,costs = best

    if args.debug_rawalign:
        for i in range(len(v1)):
            print "raw-align %3d [%3d %3d] (%3d %3d) %6.2f"%(i,v1[i],v2[i],ins[i]>>16,ins[i]&0xffff,costs[i]),unichr(outs[i])


    sresult = []
    scosts = []
    segs = []

    n = len(ins)
    i = 1
    while i<n:
        if outs[i]==ord(" "):
            sresult.append(" ")
            scosts.append(costs[i])
            segs.append((0,0))
            i += 1
            continue
        # pick up ligatures indicated by the recognizer (multiple sequential 
        # output characters with the same input segments)
        j = i+1
        while j<n and ins[j]==ins[i]:
            j += 1
        cls = "".join([ltable.chr(c) for c in outs[i:j]])
        sresult.append(cls)
        scosts.append(sum(costs[i:j]))
        start = (ins[i]>>16)
        end = (ins[i]&0xffff)
        segs.append((start,end))
        i = j

    if len(sresult)<args.minlength:
        print "*"+fst_file,": OUTSHORT/%d"%len(sresult)
        return

    if args.debug_aligned:
        for i,row in enumerate(zip(sresult,scosts,segs)):
            print "aligned",i,row

    ml = max([len(x) for x in sresult])
    lig = sum([len(x)>1 for x in sresult])
    bad = sum([x=="~" for x in sresult])
    perc = stats.scoreatpercentile(costs,args.perc)
    avg = mean(costs)
    skip = (perc > args.maxperc or avg>args.maxavg or ml>3 or lig*1.0/len(sresult)>0.1 or bad*1.0/(3.0+len(sresult))>0.1 or lig>=args.maxlig)
    aligned = fstutils.implode_transcription(sresult,maxlig=100)
    if skip:
        print "%c%s %6.2f %6.2f:"%("*" if skip else " ",fname,perc,avg),""
    else:
        print "%c%s %6.2f %6.2f:"%("*" if skip else " ",fname,perc,avg),aligned

    if skip: return

    count += 1
    in_img = lattice2image(fst)
    out_img = zeros(in_img.shape)
    out_img[:,0] = 1.0
    offset = 10
    for i in range(len(segs)):
        a,b = segs[i]
        if a==0 or b==0: continue
        # print (a,b),sresult[i]
        c = iclasses.ord(sresult[i])
        if c>=out_img.shape[1]: c = iclasses.ord("~")
        out_img[a,c] = 1.0
        out_img[a,0] = 0.0
    combo = array([in_img,out_img,zeros(in_img.shape)]).transpose([1,2,0])
    # print combo.shape
    s = [offset]+list(combo.shape[1:])
    combo = r_[zeros(s),combo,zeros(s)]
    if count%100==0:
        ion(); clf(); imshow(combo,interpolation='nearest'); ginput(1,0.0001)
    for i in range(offset,len(combo)-offset):
        subimage = combo[i-8:i+4,:,0].copy()
        if combo[i,0,1]>0.5: cls = 0
        else: cls = 4+argmax(combo[i,4:,1])
        subimage[:,:] *= 0.2
        subimage[8,:] *= 5.0
        # print cls,iclasses.chr(cls)
        # clf(); imshow(subimage,vmin=0.0,vmax=1.0); xlabel("%d %s"%(cls,iclasses.chr(cls) if cls>0 else "_")); ginput(1,10000)
        subimage = subimage.reshape(32,subimage.size/32)
        h5output.insert(subimage,iclasses.chr(cls))
    h5output.flush()
        
    return

    # read the raw segmentation
    rseg_file = ocrolib.fvariant(fname,"rseg")
    if not os.path.exists(rseg_file):
        print "*"+rseg_file,": NOT FOUND"
        return
    rseg = ocroio.read_line_segmentation(rseg_file)
    rseg_boxes = docproc.seg_boxes(rseg)

    # Now run through the segments and create a table that maps rseg
    # labels to the corresponding output element.

    assert len(sresult)==len(segs)
    assert len(scosts)==len(segs)

    bboxes = []

    rmap = zeros(amax(rseg)+1,'i')
    for i in range(1,len(segs)):
        start,end = segs[i]
        if start==0 or end==0: continue
        rmap[start:end+1] = i
        bboxes.append(rect_union(rseg_boxes[start:end+1]))
    assert rmap[0]==0

    cseg = zeros(rseg.shape,'i')
    for i in range(cseg.shape[0]):
        for j in range(cseg.shape[1]):
            cseg[i,j] = rmap[rseg[i,j]]

    assert len(segs)==len(sresult) 
    assert len(segs)==len(scosts)

    assert amin(cseg)==0,"amin(cseg)!=0 (%d,%d)"%(amin(cseg),amax(cseg))

    # first work on the list output; here, one list element should
    # correspond to each cost
    result = sresult
    assert len(result)==len(scosts),\
        "output length %d differs from cost length %d"%(len(result),len(costs))
    assert amax(cseg)<len(result),\
        "amax(cseg) %d not consistent with output length %d"%(amax(cseg),len(output_l))

    # if there are spaces at the end, trim them (since they will never have a corresponding cseg)

    while len(result)>0 and result[-1]==" ":
        result = result[:-1]
        costs = costs[:-1]

    perc = stats.scoreatpercentile(costs,50)
    avg = mean(costs)
    skip = (perc > 10.0 or avg>10.0)

    if args.suffix is not None:
        cseg_file = ocrolib.fvariant(fname,"cseg",args.suffix)
        if not args.overwrite:
            if os.path.exists(cseg_file): die("%s: already exists",cseg_file)
        ocrolib.write_line_segmentation(cseg_file,cseg)
        # aligned text line
        ocrolib.write_text(ocrolib.fvariant(fname,"txt","aligned"),aligned)
        # per character costs
        with ocrolib.fopen(fname,"costs",args.suffix,mode="w") as stream:
            for i in range(len(costs)):
                stream.write("%d %g\n"%(i,costs[i]))
        # true ground truth (best-matching line in the original transcription)
        ocrolib.write_text(ocrolib.fvariant(fname,"txt",args.suffix),bestline)

    result = []
    iraw = 0
    if args.Display:
        ion(); clf()

    line = ocrolib.read_image_gray(ocrolib.fvariant(fname,"png"))
    line = amax(line)-line
    lgeo = docproc.seg_geometry(rseg)
    grouper = ocrolib.Grouper()
    grouper.setSegmentation(rseg)
    results = []
    for i in range(grouper.length()):
        raw,mask = grouper.extractWithMask(line,i,dtype='B')
        # ion(); gray(); subplot(121); imshow(raw); subplot(122); imshow(mask); ginput(1,3)
        start = grouper.start(i)
        end = grouper.end(i)
        bbox = grouper.boundingBox(i)
        y0,x0,y1,x1 = bbox
        rel = docproc.rel_char_geom((y0,y1,x0,x1),lgeo)
        ry,rw,rh = rel
        assert rw>0 and rh>0
        if (start,end) in segs:
            index = segs.index((start,end))
            cls = sresult[index]
            cost = costs[index]
        else:
            cls = "~"
            cost = 0.0
        if cls!="~":
            if args.Display:
                iraw += 1
                subplot(args.dgrid,args.dgrid,iraw)
                gray(); imshow(raw)
                #gca().text(0.1,-0.1,"%d/%s"%(i,cls),transform=ax.transAxes,color='green')
                gca().set_frame_on(False)
                if cost>0.2:
                    ylabel("%d "%int(10*cost),color='red',size=10)
                xlabel("%-3s %d"%(cls,i),color='blue',size=10)
                xticks([])
                yticks([])
                print "output %3d %3d cls %-5s cost %6.2f    "%(start,end,cls,cost),
                print "y %6.2f w %6.2f h %6.2f"%(rel[0],rel[1],rel[2])
        if cls!="~" or args.rejects:
            if args.normalize: raw = csnormalize1(raw)
            results.append(Record(image=raw,
                                  cost=float(cost),
                                  cls=cls,
                                  count=1,
                                  file=fname,
                                  lgeo=lgeo,
                                  rel=rel,
                                  bbox=bbox))
    if args.Display: ginput(1,10000)
    return results

def safe_align1(job):
    try:
        return align1(job)
    except:
        traceback.print_exc()
        return []

jobs = []

if args.filelist:
    for line in open(args.filelist).readlines():
        image,lmod = line.strip().split(2)
        jobs.append((image,lmod))
elif args.pagegt:
    if len(args.args)==1 and os.path.isdir(args.args[0]):
        files = glob.glob(args[0]+"/*.gt.txt")
    else:
        files = args.args
    missing_pagedir = 0
    for arg in files:
        if not os.path.exists(arg):
            print "# %s: not found"%arg
            continue
        base,_ = ocrolib.allsplitext(arg)
        if not os.path.exists(base) or not os.path.isdir(base):
            # print "# %s: dir not found"
            # sys.stdout.flush()
            missing_pagedir += 1
            continue
        lines = glob.glob(base+"/??????.png")
        for line in lines:
            if not re.search(args.ppat,line): 
                continue
            jobs.append((line,arg))
    print "number of page files",len(files),"number missing line dirs",missing_pagedir
elif args.langmod:
    for arg in args.args:
        jobs.append((arg,args.langmod))
elif args.gt is not None:
    count = 0
    allfiles = []
    for arg in args.args:
        if os.path.isdir(arg) or os.path.isdir(arg+"/."):
            files = sorted(glob.glob(arg+"/????/??????.png"))
            print "adding",len(files),"files from",arg
            assert len(files)>0
            allfiles += files
        else:
            allfiles.append(arg)
            count += 1
    print "added",count,"files directly"
    for arg in allfiles:
        path,ext = ocrolib.allsplitext(arg)
        p = path+args.gt
        if not os.path.exists(arg):
            print arg,"not found"
            continue
        if not os.path.exists(p): 
            print p,"not found"
            continue
        jobs.append((arg,p))
else:
    raise Exception("you need to specify what kind of groundtruth you want to align with (-f, -p, -l, -g)")

print "got",len(jobs),"jobs"
if len(jobs)>args.nlines: jobs = jobs[:args.nlines]

for arg in jobs:
    results = align1(arg)
    if results is None: continue
    for r in results:
        extract_db.insert(image=r.image,cls=r.cls,cost=r.cost,count=1,file=r.file,lgeo=r.lgeo,rel=r.rel,bbox=r.bbox)

h5output.close()
