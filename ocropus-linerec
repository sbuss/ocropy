#!/usr/bin/python

import sys,os,re,glob,cPickle,signal
import ocropy
from ocropy import N,NI,plotutils,fstutils,linerec
from pylab import *

signal.signal(signal.SIGINT,lambda *args:sys.exit(1))

from optparse import OptionParser
prefix = "/usr/local/share/ocropus/models/"
parser = OptionParser(usage="""
%prog [options] image.png ...

Recognize models using OCRopus line recognizers.

Arguments can be a mix of image files, language models, and text files.
Each image file should represent a text line to be recognized.
If language models and text files are given, they are loaded as the default
language model for subsequent images.

For each input image, it reads image.png and image.bin.png, if it exists
(FIXME: it doesn't yet; it just reads image.png and treats it as binary.)

It produces the following output files:

* image.fst -- recognition lattice
* image.txt -- recognized output, combining the language model and recognition lattice
* image.rseg.png -- raw segmentation
* image.cseg.png -- aligned segmentation

You can get a quick idea of how recognition is working by using the -d or -D arguments.
""")
parser.add_option("-m","--linerec",help="linerec model",default=prefix+"default.model")
parser.add_option("-l","--langmod",help="language model",default=prefix+"default.fst")
parser.add_option("-w","--lweight",help="language model weight",default=1.0,type=float)
parser.add_option("-v","--verbose",help="verbose",action="store_true")
parser.add_option("-d","--display",help="display result",action="store_true")
parser.add_option("-D","--Display",help="display continuously",action="store_true")
parser.add_option("-S","--suffix",help="suffix for writing results (e.g., '.gt')",default="")
parser.add_option("-x","--gtextension",help="extension used for ground truth (ex: .txt, .gt.txt, .fst,...)",default=None)
parser.add_option("-F","--filelist",help="list of input files",default=None)

(options,args) = parser.parse_args()

if options.filelist is not None:
    assert len(args)==0
    args = open(options.filelist).readlines()
    args = [s[:-1] for s in args]

if len(args)==0:
    parser.print_help()
    sys.exit(0)

# FIXME add language model weights
assert options.lweight==1.0,"other language model weights not implemented yet"

if options.Display: options.display = 1
if options.display: ion()

# Load the line recognizer; this uses the library function that can handle
# C++ recognizers, character recognizers, and Python line recognizers, depending
# on extension (.model, .cmodel, .pymodel)
if ".cmodel" in options.linerec:
    linerec = linerec.LineRecognizer()
    linerec.load(options.linerec)
else:
    linerec = ocropy.load_linerec(options.linerec)
if options.verbose: linerec.info()

# Load the default language model (can be overridden on the command line.).
default_lmodel = ocropy.make_OcroFST()
default_lmodel.load(options.langmod)
default_lmodel_path = options.langmod

def read_lmodel(file):
    if file[-4:]==".fst":
        result = ocropy.make_OcroFST()
        result.load(file)
        return result
    else:
        result = fstutils.load_text_file_as_fst(file)
        return result

for line in args:
    base,allext = ocropy.allsplitext(line)
    _,ext = os.path.splitext(line)

    # if the file is a language model, load it
    if ext==".fst" or ext==".txt":
        default_lmodel_path = line
        default_lmodel = read_lmodel(line)
        continue
        
    # if we can find a specific language model for it then perform alignment
    lmodel = default_lmodel
    if options.gtextension is not None:
        path = base+options.gtextension
        if os.path.exists(path):
            if options.verbose: print "# using ",path
            lmodel = read_lmodel(path)
        else:
            if options.verbose: print "# ground truth missing",path
            continue
    else:
        if options.verbose: print "# using",default_lmodel_path

    # recognize the image with the given line recognizer and language model
    # FIXME read the .bin.png file if it exists.
    image = ocropy.bytearray()
    ocropy.read_image_gray(image,line)
    l = ocropy.recognize_and_align(image,linerec,lmodel)
    print "%6.2f\t%3d\t%s"%(l.cost,len(l.output),l.output)
    base,_ = ocropy.allsplitext(line)

    # write the resulting files to disk
    with open(base+options.suffix+".txt","w") as stream:
        stream.write(l.output)
    l.lattice.save(base+options.suffix+".fst")
    ocropy.write_line_segmentation(base+".rseg"+options.suffix+".png",l.rseg)
    if l.cseg is not None:
        ocropy.write_line_segmentation(base+".cseg"+options.suffix+".png",l.cseg)

    # display if requested
    if options.display:
        clf()
        axis = subplot(111)
        plotutils.draw_aligned(l,axis)
        if not options.Display: 
            raw_input("hit ENTER to continue")
        else:
            ginput(1,timeout=1)
